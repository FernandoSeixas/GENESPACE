% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/genespace_utils.R, R/plot_utils.R
\name{genespace_utils}
\alias{genespace_utils}
\alias{make_initialGenespacePipe}
\alias{reduce_recipBlast}
\alias{pull_orthologs}
\alias{write_ofBlast2file}
\alias{merge_gffWithBlast}
\alias{prep_ofDB}
\alias{find_ofFiles}
\alias{check_gsDir}
\alias{read_ogs}
\alias{make_newOFdb}
\alias{readRename_blastGenes}
\alias{read_speciesIDs}
\alias{make_mapDB}
\alias{read_geneIDs}
\alias{import_ofResults}
\alias{cull_blastByScore}
\alias{find_whichInBuffer}
\alias{run_dbs}
\alias{mirror_map}
\alias{clean_it}
\alias{format_gffChrlist}
\alias{format_mapChrlist}
\alias{convert_gff2coords}
\alias{calc_linearCoord}
\alias{add_gap}
\alias{make_fais}
\alias{draw_genePolygon}
\alias{annotate_riparian}
\alias{label_riparian}
\alias{add_alpha}
\alias{make_polygon}
\alias{round_toAny}
\alias{get_xClus}
\alias{cos_y}
\title{GENESPACE utility functions}
\usage{
make_initialGenespacePipe(
  working.directory,
  verbose,
  genomeIDs,
  cds_str,
  peptide_str,
  blast.threads,
  n.cores,
  ploidy,
  max.dup,
  min.score,
  use.topn,
  only.orthogroups,
  orthofinder.method,
  blast.rda.2start,
  MCScanX.m.param.synteny,
  MCScanX.s.param.synteny,
  dbs.radius.synteny,
  dbs.hits.synteny,
  MCScanX.m.param.extend,
  MCScanX.s.param.extend,
  extend.use.score.cull.blast,
  extend.rank.buffer,
  syntenic.rank.buffer,
  min.score4homolog,
  min.propBestScore4homolog
)

reduce_recipBlast(genomeIDs, blast, intergenome.only = F)

pull_orthologs(of.dir)

write_ofBlast2file(blast, output.dir)

merge_gffWithBlast(gff, blast, include.gene.num, include.genome.num, mirror)

prep_ofDB(
  tmp.dir,
  orig.dir,
  peptide.dir,
  output.dir,
  n.cores,
  genomeIDs,
  verbose,
  min.score,
  copy2dir = NULL
)

find_ofFiles(of.dir)

check_gsDir(dir2check, overwrite.output.dir)

read_ogs(of.dir, gff)

make_newOFdb(
  tmp.dir,
  output.dir,
  peptide.dir,
  genomeIDs,
  verbose = T,
  n.cores = 1
)

readRename_blastGenes(
  gene.dict1,
  gene.dict2,
  blast.file.in,
  blast.file.out,
  min.score = NULL,
  verbose = T
)

read_speciesIDs(of.dir, genomeIDs)

make_mapDB(id.db, of.dir, cull.blast.dir)

read_geneIDs(of.dir, gff, species.num.id)

import_ofResults(gff, of.dir, verbose = T, genomeIDs)

cull_blastByScore(
  blast.file.in,
  blast.file.out,
  maxn,
  rbh.only = F,
  verbose = T
)

find_whichInBuffer(x, y, which.in.blk, rank.buffer)

run_dbs(map, radius, n.mappings)

mirror_map(map, keycol = NULL)

clean_it(map, genomeIDs, rerank, radius, n.mappings, verbose)

format_gffChrlist(
  gff,
  genomes,
  chr.list,
  use.rank,
  gap.prop,
  do.cumulative = T
)

format_mapChrlist(
  map,
  gff,
  chr.list,
  genomes,
  forCircos = F,
  do.cumulative = T
)

convert_gff2coords(gff, chr.list, gap.prop)

calc_linearCoord(chr, start, end, gap.prop, scale.it, return.start)

add_gap(fais, gap.prop)

make_fais(genomes, gff)

draw_genePolygon(
  map,
  genes2plot,
  chr.buff,
  gene.col,
  simplify.poly,
  points.per.curve
)

annotate_riparian(
  map,
  genomes,
  chr.buff,
  dodge.geneIDs,
  scale2dodge,
  geneid.cex,
  geneid.offset,
  gene.colors,
  geneID.abbrev.fun,
  genes2plot
)

label_riparian(
  fais,
  chr.segm.lwd,
  chr.segm.col,
  genomes,
  chr.lab.buff,
  chr.bg.col,
  chr.bg.cex,
  chr.bg.pch,
  chr.id.col,
  chr.id.cex,
  lab.chr,
  lab.chr.1only,
  chr.abbrev.fun
)

add_alpha(col, alpha = 1)

make_polygon(s1, s2, e1, e2, y, fill.color, border.color, simplify.poly)

round_toAny(x, num)

get_xClus(x, n.reps, dodge.x, scale2dodge = 2)

cos_y(y.start, y.end, n.out, n.sample = n.out)
}
\arguments{
\item{verbose}{logical, should}

\item{genomeIDs}{character, length}

\item{n.cores}{integer length 1, the number of parallel processes
to run.}

\item{min.score}{numeric length 1, specifying the minimum blast
bit score for a hit to be retained.}

\item{blast}{data.table, containing the merged gff and blast results.
Unlike the 'map' object, which really just needs merged gff coordinates,
this must have all the blast8 columns. See details.}

\item{of.dir}{file.path, to the subdirectory containing
blast results}

\item{gff}{gff-like data.table}

\item{tmp.dir}{file.path, to the subdirectory
where the temporary results should be written}

\item{peptide.dir}{file.path, to the subdirectory containing
the parsed peptide files}

\item{gene.dict1}{data.table with column names V1, new1, keyed on
V1. V1 contains the original geneIDs, new1 contains the new geneIDs}

\item{gene.dict2}{data.table with column names V2, new2, keyed on
V2. V2 contains the original geneIDs, new2 contains the new geneIDs}

\item{blast.file.in}{file.path, to the blast file to read in}

\item{blast.file.out}{file.path, to the filename to which the
blast results should be written}

\item{id.db}{genome ID dictionary}

\item{cull.blast.dir}{file.path, to the subdirectory
where the culled blast results should be written}

\item{maxn}{integer length 1, indicating the maximum number of
hits to be retained per query.}

\item{x}{numeric or character, length}

\item{y}{numeric, length}

\item{map}{map-formatted data.table}

\item{radius}{numeric, the radius to search within for syntenic
mappings. Length must match that of n.mappings.}

\item{n.mappings}{numeric, the number of mappings required within a
given radius. Length must match that of radius}

\item{genomes}{character, length}

\item{chr.list}{list of chromosomes to plot}

\item{use.rank}{logical, should}

\item{gap.prop}{numeric, length}

\item{do.cumulative}{logical, should}

\item{forCircos}{logical, should}

\item{chr}{character, length}

\item{start}{numeric, length}

\item{end}{numeric, length}

\item{scale.it}{logical, should}

\item{return.start}{logical, should}

\item{fais}{fai-like data.table}

\item{genes2plot}{character, length}

\item{chr.buff}{numeric, length}

\item{simplify.poly}{logical, should}

\item{points.per.curve}{numeric, length}

\item{dodge.geneIDs}{numeric, length}

\item{scale2dodge}{numeric, length}

\item{geneid.cex}{numeric, length}

\item{geneid.offset}{numeric, length}

\item{gene.colors}{character, length}

\item{geneID.abbrev.fun}{function to}

\item{chr.segm.lwd}{numeric, length}

\item{chr.segm.col}{character, length}

\item{chr.lab.buff}{numeric, length}

\item{chr.bg.col}{character, length}

\item{chr.bg.cex}{numeric, length}

\item{chr.bg.pch}{numeric, length}

\item{chr.id.col}{character, length}

\item{chr.id.cex}{numeric, length}

\item{lab.chr}{logical, should}

\item{lab.chr.1only}{logical, should}

\item{chr.abbrev.fun}{function to}

\item{col}{character, length}

\item{alpha}{numeric, length}

\item{s1}{numeric, length}

\item{s2}{numeric, length}

\item{e1}{numeric, length}

\item{e2}{numeric, length}

\item{fill.color}{character, length}

\item{border.color}{character, length}

\item{num}{numeric, length}

\item{n.reps}{numeric, length}

\item{dodge.x}{numeric, length}

\item{y.start}{numeric, length}

\item{y.end}{numeric, length}

\item{n.out}{numeric, length}

\item{n.sample}{numeric, length}

\item{dir.list}{list, containing the paths to various genespace
subdirectories.}

\item{...}{Not currently in use}

\item{bg.col}{character, length}

\item{blk}{block-formatted data.table}

\item{blk.border}{numeric, length}

\item{blk.ids}{character, length}

\item{chr.buffer}{numeric, length}

\item{cols}{character, length}

\item{ortho.col}{character, length}
}
\description{
\code{genespace_utils} Functions for GENESPACE

\code{make_initialGenespacePipe} make_initialGenespacePipe

\code{reduce_recipBlast} reduce_recipBlast

\code{pull_orthologs} pull_orthologs

\code{write_ofBlast2file} write_ofBlast2file

\code{merge_gffWithBlast} merge_gffWithBlast

\code{prep_ofDB} prep_ofDB

\code{find_ofFiles} find_ofFiles

\code{check_gsDir} check_gsDir

\code{read_ogs} fread_ogs

\code{make_newOFdb} make_newOFdb

\code{readRename_blastGenes} readRename_blastGenes

\code{read_speciesIDs} read_speciesIDs

\code{make_mapDB} make_mapDB

\code{read_geneIDs} read_geneIDs

\code{import_ofResults} import_ofResults

\code{cull_blastByScore} cull_blastByScore

\code{find_whichInBuffer} find_whichInBuffer

\code{run_dbs} run_dbs

\code{mirror_map} mirror_map

\code{clean_it} clean_it

\code{plot_utils} Functions that allow selection stat calculation in GENESPACE

\code{format_gffChrlist} rename and simplify gff

\code{format_mapChrlist} rename and simplify map

\code{convert_gff2coords} makes blocks and merges by block.id

\code{calc_linearCoord} convert start / end positions into
linear coordinates..

\code{add_gap} add gap to linear chromosome x axis.

\code{make_fais} make data.table akin to fasta index.

\code{draw_genePolygon} draw gene Polygon

\code{annotate_riparian} annotate_riparian

\code{label_riparian} label_riparian

\code{add_alpha} add transparency to a color.

\code{make_polygon} given a y string and start/end coords, draw a polygon

\code{round_toAny} round_toAny

\code{get_xClus} for a set of x,

\code{cos_y} given a range of x, return a cosine curve.
}
\note{
\code{genespace_utils} is a generic name for the functions documented.
\cr
If called, \code{genespace_utils} returns its own arguments.

\code{plot_utils} is a generic name for the functions documented.
\cr
If called, \code{plotutils} returns its own arguments.
}
