% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/genespace_utils.R, R/plot_utils.R
\name{genespace_utils}
\alias{genespace_utils}
\alias{read_ogs}
\alias{make_newOFdb}
\alias{readRename_blastGenes}
\alias{read_speciesIDs}
\alias{make_mapDB}
\alias{read_geneIDs}
\alias{import_ofResults}
\alias{cull_blastByScore}
\alias{find_whichInBuffer}
\alias{run_dbs}
\alias{run_mcs}
\alias{mirror_map}
\alias{clean_it}
\alias{format_gffChrlist}
\alias{format_mapChrlist}
\alias{convert_gff2coords}
\alias{calc_linearCoord}
\alias{add_gap}
\alias{make_fais}
\alias{draw_genePolygon}
\alias{annotate_riparian}
\alias{label_riparian}
\alias{add_alpha}
\alias{make_polygon}
\alias{round_toAny}
\alias{get_xClus}
\alias{cos_y}
\title{GENESPACE utility functions}
\usage{
read_ogs(of.dir, gff)

make_newOFdb(tmp.dir, cull.blast.dir, peptide.dir, genomeIDs,
  verbose = T, n.cores = 1)

readRename_blastGenes(gene.dict1, gene.dict2, blast.file.in,
  blast.file.out, min.score = NULL, verbose = T)

read_speciesIDs(of.dir, genomeIDs)

make_mapDB(id.db, of.dir, cull.blast.dir)

read_geneIDs(of.dir, gff)

import_ofResults(gff, of.dir, verbose = T, genomeIDs)

cull_blastByScore(blast.file.in, blast.file.out, maxn, verbose = T)

find_whichInBuffer(x, y, which.in.blk, rank.buffer)

run_dbs(map, radius, n.mappings)

run_mcs(blast, gff, genomeIDs, mcscan.dir, MCScanX.tool, mcscan.param,
  silent.mcs)

mirror_map(map, keycol = NULL)

clean_it(map, genomeIDs, rerank, radius, n.mappings, verbose)

format_gffChrlist(gff, genomes, chr.list, use.rank, gap.prop,
  do.cumulative = T)

format_mapChrlist(map, gff, chr.list, genomes, forCircos = F,
  do.cumulative = T)

convert_gff2coords(gff, chr.list, gap.prop)

calc_linearCoord(chr, start, end, gap.prop, scale.it, return.start)

add_gap(fais, gap.prop)

make_fais(genomes, gff)

draw_genePolygon(map, genes2plot, chr.buff, ortho.col, simplify.poly,
  points.per.curve)

annotate_riparian(map, genomes, chr.buff, dodge.geneIDs, scale2dodge,
  geneid.cex, geneid.offset, gene.colors, geneID.abbrev.fun, genes2plot)

label_riparian(fais, chr.segm.lwd, chr.segm.col, genomes, chr.lab.buff,
  chr.bg.col, chr.bg.cex, chr.bg.pch, chr.id.col, chr.id.cex, lab.chr,
  lab.chr.1only, chr.abbrev.fun)

add_alpha(col, alpha = 1)

make_polygon(s1, s2, e1, e2, y, fill.color, border.color, simplify.poly)

round_toAny(x, num)

get_xClus(x, n.reps, dodge.x, scale2dodge = 2)

cos_y(y.start, y.end, n.out, n.sample = n.out)
}
\arguments{
\item{of.dir}{file.path, to the subdirectory containing
blast results}

\item{gff}{data.table, containing the parsed gff annotations,
as produced by import_gff.}

\item{tmp.dir}{file.path, to the subdirectory
where the temporary results should be written}

\item{cull.blast.dir}{file.path, to the subdirectory
where the culled blast results should be written}

\item{peptide.dir}{file.path, to the subdirectory containing
the parsed peptide files}

\item{genomeIDs}{character vector, specifying the genomeIDs to include.}

\item{verbose}{logical, should updates be printed to the console?}

\item{n.cores}{integer length 1, the number of parallel processes
to run.}

\item{gene.dict1}{data.table with column names V1, new1, keyed on
V1. V1 contains the original geneIDs, new1 contains the new geneIDs}

\item{gene.dict2}{data.table with column names V2, new2, keyed on
V2. V2 contains the original geneIDs, new2 contains the new geneIDs}

\item{blast.file.in}{file.path, to the blast file to read in}

\item{blast.file.out}{file.path, to the filename to which the
blast results should be written}

\item{min.score}{numeric length 1, specifying the minimum blast
bit score for a hit to be retained.}

\item{id.db}{genome ID dictionary}

\item{maxn}{integer length 1, indicating the maximum number of
hits to be retained per query.}

\item{x}{numeric or character, length}

\item{y}{numeric, length}

\item{map}{data.table, containing the merged gff and blast results}

\item{radius}{numeric, the radius to search within for syntenic
mappings. Length must match that of n.mappings.}

\item{n.mappings}{numeric, the number of mappings required within a
given radius. Length must match that of radius}

\item{blast}{data.table, containing the merged gff and blast results.
Unlike the 'map' object, which really just needs merged gff coordinates,
this must have all the blast8 columns. See details.}

\item{mcscan.dir}{file.path, to the subdirectory containing
the mcscanx output, or where mcscanx results should be written.}

\item{MCScanX.tool}{file.path, specifying the path to the
MCScanX program.}

\item{mcscan.param}{character string, of all parameters to
pass to MCScanX}

\item{silent.mcs}{logical, should MCScanX progress be reported?}

\item{genomes}{character, length}

\item{chr.list}{list of chromosomes to plot}

\item{use.rank}{logical, should}

\item{gap.prop}{numeric, length}

\item{do.cumulative}{logical, should}

\item{forCircos}{logical, should}

\item{chr}{character, length}

\item{start}{numeric, length}

\item{end}{numeric, length}

\item{scale.it}{logical, should}

\item{return.start}{logical, should}

\item{fais}{fai-like data.table}

\item{genes2plot}{character, length}

\item{chr.buff}{numeric, length}

\item{ortho.col}{character, length}

\item{simplify.poly}{logical, should}

\item{points.per.curve}{numeric, length}

\item{dodge.geneIDs}{numeric, length}

\item{scale2dodge}{numeric, length}

\item{geneid.cex}{numeric, length}

\item{geneid.offset}{numeric, length}

\item{gene.colors}{character, length}

\item{geneID.abbrev.fun}{function to}

\item{chr.segm.lwd}{numeric, length}

\item{chr.segm.col}{character, length}

\item{chr.lab.buff}{numeric, length}

\item{chr.bg.col}{character, length}

\item{chr.bg.cex}{numeric, length}

\item{chr.bg.pch}{numeric, length}

\item{chr.id.col}{character, length}

\item{chr.id.cex}{numeric, length}

\item{lab.chr}{logical, should}

\item{lab.chr.1only}{logical, should}

\item{chr.abbrev.fun}{function to}

\item{col}{character, length}

\item{alpha}{numeric, length}

\item{s1}{numeric, length}

\item{s2}{numeric, length}

\item{e1}{numeric, length}

\item{e2}{numeric, length}

\item{fill.color}{character, length}

\item{border.color}{character, length}

\item{num}{numeric, length}

\item{n.reps}{numeric, length}

\item{dodge.x}{numeric, length}

\item{y.start}{numeric, length}

\item{y.end}{numeric, length}

\item{n.out}{numeric, length}

\item{n.sample}{numeric, length}

\item{dir.list}{list, containing the paths to various genespace
subdirectories.}

\item{...}{Not currently in use}

\item{bg.col}{character, length}

\item{blk}{block-formatted data.table}

\item{blk.border}{numeric, length}

\item{blk.ids}{character, length}

\item{chr.buffer}{numeric, length}

\item{cols}{character, length}

\item{genomeIDs}{character, length}

\item{gff}{gff-like data.table}

\item{map}{map-formatted data.table}

\item{verbose}{logical, should}
}
\description{
\code{genespace_utils} Functions for GENESPACE

\code{read_ogs} fread_ogs

\code{make_newOFdb} make_newOFdb

\code{readRename_blastGenes} readRename_blastGenes

\code{read_speciesIDs} read_speciesIDs

\code{make_mapDB} make_mapDB

\code{read_geneIDs} read_geneIDs

\code{import_ofResults} import_ofResults

\code{cull_blastByScore} cull_blastByScore

\code{find_whichInBuffer} find_whichInBuffer

\code{run_dbs} run_dbs

\code{run_mcs} run_mcs

\code{mirror_map} mirror_map

\code{clean_it} clean_it

\code{plot_utils} Functions that allow selection stat calculation in GENESPACE

\code{format_gffChrlist} rename and simplify gff

\code{format_mapChrlist} rename and simplify map

\code{convert_gff2coords} makes blocks and merges by block.id

\code{calc_linearCoord} convert start / end positions into
linear coordinates..

\code{add_gap} add gap to linear chromosome x axis.

\code{make_fais} make data.table akin to fasta index.

\code{draw_genePolygon} draw gene Polygon

\code{annotate_riparian} annotate_riparian

\code{label_riparian} label_riparian

\code{add_alpha} add transparency to a color.

\code{make_polygon} given a y string and start/end coords, draw a polygon

\code{round_toAny} round_toAny

\code{get_xClus} for a set of x,

\code{cos_y} given a range of x, return a cosine curve.
}
\note{
\code{genespace_utils} is a generic name for the functions documented.
\cr
If called, \code{genespace_utils} returns its own arguments.

\code{plot_utils} is a generic name for the functions documented.
\cr
If called, \code{plotutils} returns its own arguments.
}
