% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/genespace_utils.R
\name{genespace_utils}
\alias{genespace_utils}
\alias{parse_fastaHeader}
\alias{make_newOFdb}
\alias{parse_gff}
\alias{import_gff}
\alias{read_speciesIDs}
\alias{make_mapDB}
\alias{read_geneIDs}
\alias{readRename_blastGenes}
\alias{cull_blastByScore}
\alias{read_ogs}
\alias{make_blocks}
\alias{run_dbs}
\alias{clean_it}
\alias{import_ofResults}
\alias{read_allBlasts}
\alias{merge_ofGff}
\alias{rerun_pairwiseOF}
\alias{prep_mcs}
\alias{parse_mcs}
\alias{run_mcs}
\alias{pipe_mcscanx}
\alias{cull_blast2MapChr}
\alias{cull_blast2NewIds}
\alias{find_whichInBuffer}
\alias{find_hitsInBuffer}
\alias{cull_syntenicBlast}
\alias{rerank_fromIDs}
\alias{extract_seqIDs}
\alias{write_ofBlast}
\alias{write_ofData}
\alias{format_gffChrlist}
\alias{format_mapChrlist}
\alias{convert_gff2coords}
\alias{calc_linearCoord}
\alias{add_gap}
\alias{make_fais}
\alias{draw_genePolygon}
\alias{annotate_riparian}
\alias{label_riparian}
\alias{add_alpha}
\alias{make_polygon}
\alias{round_toAny}
\alias{get_xClus}
\alias{cos_y}
\alias{track_blocks}
\alias{mirror_blast}
\alias{run_of}
\alias{build_globalBlocks}
\alias{pull_synHomos}
\alias{pull_nonSynOrthos}
\alias{simplify_map}
\alias{drop_mapDup}
\alias{extend_blk2chrend}
\alias{pull_duplicatesInChr}
\alias{find_blocksToExtend}
\alias{find_leftBlk}
\alias{find_rightBlk}
\title{selection utility functions}
\usage{
parse_fastaHeader(fasta.dir, is.peptide = T, pattern = "fa",
  verbose = T, parse_fastaHeader.FUN)

make_newOFdb(tmp.dir, cull.blast.dir, peptide.dir, genomeIDs,
  verbose = T, n.of.cores = 1)

parse_gff(gff.file, str2drop = "Name=", str2parse = ";",
  use = "gene", whichAttr = 2)

import_gff(gff.dir, genomeIDs, use = "gene", verbose = T,
  str2drop = "Name=", str2parse = ";", whichAttr = 2)

read_speciesIDs(of.dir, genomeIDs)

make_mapDB(id.db, blast.dir, cull.blast.dir)

read_geneIDs(of.dir, gff)

readRename_blastGenes(gene.dict1, gene.dict2, blast.file.in,
  blast.file.out, verbose = T)

cull_blastByScore(blast.file.in, blast.file.out, maxn, verbose = T)

read_ogs(of.dir, gff)

make_blocks(map, rerank = T, drop.NAs = F, rename.blocks = F,
  add.metadata = F, clean.columns = T, ties.method = "dense")

run_dbs(y, eps.radius, mappings)

clean_it(map, genomeIDs, rerank, radius, n.mappings, by.blk = F, verbose)

import_ofResults(gff, blast.dir, verbose = T, genomeIDs)

read_allBlasts(gff, genomeIDs, blast.dir, check.ogs = T, add.gff = F,
  keep.geneNum = F, verbose = T)

merge_ofGff(comb, pw.of, gff, dir.list, use.recip = T, verbose = T)

rerun_pairwiseOF(dir.list, gff, genomeIDs, n.cores = 6, verbose = T)

prep_mcs(blast, gff, genomeIDs, mcscan.dir, mcscan.param, MCScanX.path,
  silent.mcs)

parse_mcs(mcs.file)

run_mcs(blast, gff, genomeIDs, mcscan.dir, MCScanX.path, mcscan.param,
  silent.mcs)

pipe_mcscanx(blast, gff, genomeIDs, mcscan.dir, mcscan.param, MCScanX.path,
  split.by.blk = F, silent.mcs = T, verbose = T)

cull_blast2MapChr(map, blast)

cull_blast2NewIds(blast, map)

find_whichInBuffer(x, y, which.in.blk, rank.buffer)

find_hitsInBuffer(map, blast, rank.buffer, verbose)

cull_syntenicBlast(map, blast, gff, rank.buffer, verbose = T)

rerank_fromIDs(map, gff)

extract_seqIDs(blast, genomeIDs)

write_ofBlast(blast, of.ids, blast.ids, of.dir)

write_ofData(blast, genomeIDs, of.dir, peptide.dir, verbose = T)

format_gffChrlist(gff, genomes, chr.list, use.rank, gap.prop,
  do.cumulative = T)

format_mapChrlist(map, gff, chr.list, genomes, forCircos = F,
  do.cumulative = T)

convert_gff2coords(gff, chr.list, gap.prop)

calc_linearCoord(chr, start, end, gap.prop, scale.it, return.start)

add_gap(fais, gap.prop)

make_fais(genomes, gff)

draw_genePolygon(map, genes2plot, chr.buff, ortho.col, simplify.poly,
  points.per.curve)

annotate_riparian(map, genomes, chr.buff, dodge.geneIDs, scale2dodge,
  geneid.cex, geneid.offset, gene.colors, geneID.abbrev.fun, genes2plot)

label_riparian(fais, chr.segm.lwd, chr.segm.col, genomes, chr.lab.buff,
  chr.bg.col, chr.bg.cex, chr.bg.pch, chr.id.col, chr.id.cex, lab.chr,
  lab.chr.1only, chr.abbrev.fun)

add_alpha(col, alpha = 1)

make_polygon(s1, s2, e1, e2, y, fill.color, border.color, simplify.poly)

round_toAny(x, num)

get_xClus(x, n.reps, dodge.x, scale2dodge = 2)

cos_y(y.start, y.end, n.out, n.sample = n.out)

track_blocks(map, blk.ids, cols, bg.col)

mirror_blast(blast, w2ki, genomes)

run_of(tmp.dir, blast.dir, genomeIDs, n.cores, gff)

build_globalBlocks(dir.list, gff, genomeIDs, MCScanX.path, n.cores,
  use.topn, min.blockSize, m.param, only.orthogroups)

pull_synHomos(syn.blast, syn.ortho.map, min.score, prop.of.best,
  min.perc.iden)

pull_nonSynOrthos(of.blast, map, gff, rank.buffer, verbose = T)

simplify_map(map, n.mapping, radius, genomeIDs, keep.best.id1.hit)

drop_mapDup(map)

extend_blk2chrend(blk, gff, map, genomeIDs, min.dist2end)

pull_duplicatesInChr(map.bychr, gff)

find_blocksToExtend(blk, chr.end.buffer = 5, ovl.buffer = 3,
  same.chr.buffer = 500, verbose = T)

find_leftBlk(st.rank, end.ranks, chrs, chr, ovl.buffer, same.chr.buffer)

find_rightBlk(st.ranks, end.rank, chrs, chr, ovl.buffer, same.chr.buffer)
}
\arguments{
\item{fasta.dir}{file path to}

\item{is.peptide}{logical, should}

\item{pattern}{character, length}

\item{verbose}{logical, should}

\item{parse_fastaHeader.FUN}{function to}

\item{tmp.dir}{file path to}

\item{cull.blast.dir}{file path to}

\item{peptide.dir}{file path to}

\item{genomeIDs}{character, length}

\item{n.of.cores}{numeric, length}

\item{gff.file}{file path to}

\item{str2drop}{character, length}

\item{str2parse}{character, length}

\item{whichAttr}{numeric, length}

\item{gff.dir}{file path to}

\item{of.dir}{file path to}

\item{id.db}{database of gene IDs / numbers}

\item{blast.dir}{file path to}

\item{gff}{gff-like data.table}

\item{gene.dict1}{gene dictionary}

\item{gene.dict2}{gene dictionary}

\item{blast.file.in}{file path to}

\item{blast.file.out}{file path to}

\item{maxn}{numeric, length}

\item{map}{map-formatted data.table}

\item{rerank}{logical, should}

\item{drop.NAs}{logical, should}

\item{rename.blocks}{logical, should}

\item{add.metadata}{logical, should}

\item{clean.columns}{logical, should}

\item{ties.method}{character, length}

\item{y}{numeric, length}

\item{eps.radius}{numeric, length}

\item{mappings}{numeric, length}

\item{radius}{numeric, length}

\item{n.mappings}{numeric, length}

\item{check.ogs}{logical, should}

\item{add.gff}{logical, should}

\item{keep.geneNum}{logical, should}

\item{comb}{genome combinations}

\item{pw.of}{logical, should}

\item{dir.list}{list of file paths to}

\item{use.recip}{logical, should}

\item{n.cores}{numeric, length}

\item{blast}{map-formatted data.table, without blockID info.}

\item{mcscan.dir}{file path to}

\item{mcscan.param}{character, length}

\item{MCScanX.path}{file path to}

\item{silent.mcs}{logical, should}

\item{mcs.file}{file path to}

\item{x}{numeric or character, length}

\item{which.in.blk}{numeric, length}

\item{rank.buffer}{numeric, length}

\item{of.ids}{character, length}

\item{blast.ids}{character, length}

\item{genomes}{character, length}

\item{chr.list}{list of chromosomes to plot}

\item{use.rank}{logical, should}

\item{gap.prop}{numeric, length}

\item{do.cumulative}{logical, should}

\item{forCircos}{logical, should}

\item{chr}{character, length}

\item{start}{numeric, length}

\item{end}{numeric, length}

\item{scale.it}{logical, should}

\item{return.start}{logical, should}

\item{fais}{fai-like data.table}

\item{genes2plot}{character, length}

\item{chr.buff}{numeric, length}

\item{ortho.col}{character, length}

\item{simplify.poly}{logical, should}

\item{points.per.curve}{numeric, length}

\item{dodge.geneIDs}{numeric, length}

\item{scale2dodge}{numeric, length}

\item{geneid.cex}{numeric, length}

\item{geneid.offset}{numeric, length}

\item{gene.colors}{character, length}

\item{geneID.abbrev.fun}{function to}

\item{chr.segm.lwd}{numeric, length}

\item{chr.segm.col}{character, length}

\item{chr.lab.buff}{numeric, length}

\item{chr.bg.col}{character, length}

\item{chr.bg.cex}{numeric, length}

\item{chr.bg.pch}{numeric, length}

\item{chr.id.col}{character, length}

\item{chr.id.cex}{numeric, length}

\item{lab.chr}{logical, should}

\item{lab.chr.1only}{logical, should}

\item{chr.abbrev.fun}{function to}

\item{col}{character, length}

\item{alpha}{numeric, length}

\item{s1}{numeric, length}

\item{s2}{numeric, length}

\item{e1}{numeric, length}

\item{e2}{numeric, length}

\item{fill.color}{character, length}

\item{border.color}{character, length}

\item{num}{numeric, length}

\item{n.reps}{numeric, length}

\item{dodge.x}{numeric, length}

\item{y.start}{numeric, length}

\item{y.end}{numeric, length}

\item{n.out}{numeric, length}

\item{n.sample}{numeric, length}

\item{blk.ids}{character, length}

\item{cols}{character, length}

\item{bg.col}{character, length}

\item{w2ki}{numeric vector specifying which genome comparisons to keep}

\item{use.topn}{logical, should}

\item{min.blockSize}{numeric, length}

\item{m.param}{numeric, length}

\item{only.orthogroups}{logical, should}

\item{syn.blast}{syntenic blast, map format data.table}

\item{syn.ortho.map}{syntenic orthologous blast, map format data.table}

\item{min.score}{numeric, length}

\item{prop.of.best}{numeric, length}

\item{min.perc.iden}{numeric, length}

\item{of.blast}{blast file from orthofinder}

\item{n.mapping}{numeric, length}

\item{keep.best.id1.hit}{logical, should}

\item{blk}{block-formatted data.table}

\item{min.dist2end}{numeric, length}

\item{map.bychr}{map-formatted data.table split by chr}

\item{blk.border}{numeric, length}

\item{chr.buffer}{numeric, length}
}
\description{
\code{genespace_utils} Functions that allow selection stat calculation in GENESPACE

\code{parse_fastaHeader} Rename fasta header to match the gff.

\code{make_newOFdb} make_newOFdb

\code{parse_gff} parse_gff

\code{import_gff} import_gff

\code{read_speciesIDs} read_speciesIDs

\code{make_mapDB} make_mapDB

\code{read_geneIDs} read_geneIDs

\code{readRename_blastGenes} readRename_blastGenes

\code{cull_blastByScore} cull_blastByScore

\code{read_ogs} fread_ogs

\code{make_blocks} make_blocks

\code{run_dbs} run_dbs

\code{clean_it} clean_it

\code{import_ofResults} import_ofResults

\code{read_allBlasts} read_allBlasts

\code{read_ogs} merge_ofGff

\code{rerun_pairwiseOF} rerun_pairwiseOF

\code{prep_mcs} prep_mcs

\code{parse_mcs} parse_mcs

\code{run_mcs} run_mcs

\code{pipe_mcscanx} pipe_mcscanx

\code{cull_blast2MapChr} cull_blast2MapChr

\code{cull_blast2NewIds} cull_blast2NewIds

\code{find_whichInBuffer} find_whichInBuffer

\code{find_hitsInBuffer} find_hitsInBuffer

\code{cull_syntenicBlast} cull_syntenicBlast

\code{rerank_fromIDs} rerank_fromIDs

\code{extract_seqIDs} extract_seqIDs

\code{write_ofBlast} write_ofBlast

\code{write_ofData} write_ofData

\code{format_gffChrlist} rename and simplify gff

\code{format_mapChrlist} rename and simplify map

\code{convert_gff2coords} makes blocks and merges by block.id

\code{calc_linearCoord} convert start / end positions into
linear coordinates..

\code{add_gap} add gap to linear chromosome x axis.

\code{make_fais} make data.table akin to fasta index.

\code{draw_genePolygon} draw gene Polygon

\code{annotate_riparian} annotate_riparian

\code{label_riparian} label_riparian

\code{add_alpha} add transparency to a color.

\code{make_polygon} given a y string and start/end coords, draw a polygon

\code{round_toAny} round_toAny

\code{get_xClus} for a set of x,

\code{cos_y} given a range of x, return a cosine curve.

\code{track_blocks} track blocks

\code{mirror_blast} mirror_blast

\code{run_of} run_of

\code{run_of} run_of

\code{pull_synHomos} pull_synHomos

\code{pull_nonSynOrthos} pull_nonSynOrthos

\code{simplify_map} simplify_map

\code{drop_mapDup} drop_mapDup

\code{extend_blk2chrend} extend_blk2chrend

\code{pull_duplicatesInChr} pull_duplicatesInChr

\code{find_blocksToExtend} find_blocksToExtend

\code{find_leftBlk} find_leftBlk

\code{find_rightBlk} find_rightBlk
}
\note{
\code{genespace_utils} is a generic name for the functions documented.
\cr
If called, \code{genespace_utils} returns its own arguments.
}
