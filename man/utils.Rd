% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{utils}
\alias{utils}
\alias{order_filesByMtime}
\alias{check_orthofinderInstall}
\alias{check_logicalArg}
\alias{add_rle}
\alias{clus_igraph}
\alias{get_nAA}
\alias{find_modalValue}
\alias{scale_between}
\alias{complete_subgraph}
\alias{flatten_list}
\alias{check_minPepLen}
\alias{check_dropInterSize}
\alias{are_colors}
\alias{add_alpha}
\alias{pull_strWidth}
\alias{round_toInteger}
\alias{calc_partialSw}
\alias{read_gff}
\alias{read_orthofinderSpeciesIDs}
\alias{read_orthofinderSequenceIDs}
\alias{choose_mostRecentOF}
\alias{parse_ogs}
\alias{parse_orthologues}
\alias{read_blast}
\alias{draw_scaleBar}
\alias{cosine_points}
\alias{calc_curvePolygon}
\alias{round_rect}
\alias{interp_linear}
\alias{add_ofID2gff}
\alias{add_pepLen2gff}
\alias{drop_unusedPeptides}
\alias{prep_ofDbFromPeptide}
\alias{find_orthofinderResults}
\alias{calc_blkCoords}
\alias{finalize_blocks}
\alias{parse_blast4synteny}
\alias{find_hitsInBuff}
\alias{clus_dbscan}
\alias{find_globalAnchors}
\alias{pipe_synteny}
\alias{pull_nonSelfReg}
\alias{pull_selfRegion}
\alias{get_hitsInBlks}
\alias{split_overlaps}
\alias{annotate_gff}
\alias{add_arrayRep2gff}
\alias{add_arrays2gff}
\alias{add_synOg2gff}
\alias{combine_inblkSynOG}
\alias{pull_nonSynOrthologs}
\alias{pull_blkAnchors}
\title{Generic internal functions used by genespace}
\usage{
order_filesByMtime(path = getwd(), pattern = "*", recursive = F)

check_orthofinderInstall(path)

check_logicalArg(x)

add_rle(x, which = "n")

clus_igraph(id1, id2)

get_nAA(path, raw = FALSE)

find_modalValue(x)

scale_between(x, min, max, scale1toMean = TRUE)

complete_subgraph(dt)

flatten_list(x)

check_minPepLen(x)

check_dropInterSize(x)

are_colors(col)

add_alpha(col, alpha = 1)

scale_between(x, min, max, scale1toMean = TRUE)

pull_strWidth(x, width)

round_toInteger(x, to)

calc_partialSw(
  dt,
  byGrpCol,
  windowSize,
  yCol,
  fun = function(x) mean(x, na.rm = T)
)

read_gff(gffFiles)

read_orthofinderSpeciesIDs(path)

read_orthofinderSequenceIDs(path)

choose_mostRecentOF(path)

parse_ogs(gsParam)

parse_orthologues(gsParam, refGenome, nCores = 1)

read_blast(
  blFile = NULL,
  ofID1 = NULL,
  ofID2 = NULL,
  path = NULL,
  onlyIDScore = TRUE
)

draw_scaleBar(x, y, yspan, xspan, label, lwd, cex)

cosine_points()

calc_curvePolygon(start1, end1 = NULL, start2, end2 = NULL, y1, y2)

round_rect(xleft, ybottom, xright, ytop)

interp_linear(x, y, interpTails = TRUE)

add_ofID2gff(gff, blastDir)

add_pepLen2gff(gff, gsParam)

drop_unusedPeptides(gsParam)

prep_ofDbFromPeptide(gsParam)

find_orthofinderResults(gsParam, onlyCheckRun = F)

calc_blkCoords(hits)

finalize_blocks(
  hits,
  synParam,
  gsParam,
  type = "primary",
  verbose = FALSE,
  minRbhScore = 50
)

parse_blast4synteny(gsParam, genome1, genome2, gff, selfOnly)

find_hitsInBuff(hits, nCores, synBuff)

clus_dbscan(hits, radius, blkSize, nCores)

find_globalAnchors(hits, gsParam, synParam, type = "primary")

pipe_synteny(gsParam, gff, maskHits, synParam, type = "primary")

pull_nonSelfReg(hits, selfRegionMask, nhits)

pull_selfRegion(hits, synBuff)

get_hitsInBlks(blks, hits, nCores)

split_overlaps(
  hits,
  dropInterleavesSmallerThan,
  minPropDup = 0.05,
  maxIter = 20,
  verbose
)

annotate_gff(gsParam, genomeIDs = NULL, overwrite = FALSE)

add_arrayRep2gff(gff, gsParam)

add_arrays2gff(gsParam, gff)

add_synOg2gff(gff, hits = NULL, gsParam, genomeIDs, allowRBHinOg, useBlks)

combine_inblkSynOG(genomeIDs, gff, gsParam)

pull_nonSynOrthologs(gsParam, gff)

pull_blkAnchors(gsParam, gff, refGenome)
}
\arguments{
\item{path}{file path character string}

\item{pattern}{regular expression to search for}

\item{recursive}{logical, should the search be recursive}

\item{x}{x position of the scale bar}

\item{which}{character specifying which method to use}

\item{id1}{character vector of ids with length matching id2}

\item{id2}{character vector of ids with length matching id1}

\item{raw}{logical, should a raw vector of peptide widths be returned?}

\item{min}{numeric, length 1 specifying the minumum value in the scaled data}

\item{max}{numeric, length 1 specifying the maximum value in the scaled data}

\item{scale1toMean}{logical, if single value, should it be the mean?}

\item{dt}{data.table with the first two columns as id1, id2.}

\item{col}{a vector of colors}

\item{alpha}{numeric 0-1, specifying transparency}

\item{width}{integer, the number of characters to return in string.}

\item{to}{what should the value be rounded to?}

\item{byGrpCol}{column which serves as the by factor}

\item{windowSize}{integer specifying the window size}

\item{yCol}{character specifying the column name containing the y values}

\item{fun}{function to pass to sliding window}

\item{gffFiles}{vector of file paths pointing to the gff files}

\item{gsParam}{list of genespace parameters}

\item{refGenome}{character string specifying which genome is the reference}

\item{nCores}{integer of length 1 specifying the number of parallel processes
to run}

\item{blFile}{file path to the blast-like text file}

\item{ofID1}{orthofinder ID of the first gene}

\item{ofID2}{orthofinder ID of the second gene}

\item{onlyIDScore}{logical, should only the geneIDs and score be returned?}

\item{y}{y position of the scale bar}

\item{yspan}{amount of span on the y axis}

\item{xspan}{amount of span on the x axis}

\item{label}{scale bar label}

\item{lwd}{line thickness for scale bar}

\item{cex}{scale bar label character expansion}

\item{start1}{numeric, specifying the coordinate of blk start in genome1}

\item{end1}{numeric, specifying the coordinate of  blk end in genome1}

\item{start2}{numeric, specifying the coordinate of  blk start in genome2}

\item{end2}{numeric, specifying the coordinate of blk end in genome2}

\item{y1}{numeric, specifying the coordinate of y position in genome1}

\item{y2}{numeric, specifying the coordinate of  y position in genome1}

\item{xleft}{numeric, specifying the coordinate of left x position}

\item{ybottom}{numeric, specifying the coordinate of lower y position}

\item{xright}{numeric, specifying the coordinate of right x position}

\item{ytop}{numeric, specifying the coordinate of upper y position}

\item{interpTails}{logical, should unbounded tails be interpolated?}

\item{gff}{annotated gff with orthogroups included, see read_gff}

\item{blastDir}{file.path to the location of the blast results.}

\item{onlyCheckRun}{logical, should the run just be checked?}

\item{hits}{data.table containing annotated blast-format pairwise hits}

\item{synParam}{data.table with synteny parameters. See set_syntenyParams.}

\item{type}{either 'primary' or 'secondary' depending on the scale of
inference}

\item{verbose}{logical, should updates be printed to the console?
\cr
If called, \code{utils} returns its own arguments.}

\item{minRbhScore}{integer of length 1, see set_syntenyParams}

\item{genome1}{character string specifying first of two genomeIDs}

\item{genome2}{character string specifying second of two genomeIDs}

\item{selfOnly}{logical, should only self hits be considered}

\item{synBuff}{integer of length 1 specifying the maximum euclidean distance
from an 'anchor' so that it can be considered syntenic}

\item{radius}{numeric of length 1 specifying the eps dbscan parameter; the
search radius within which to count clustered density-based xy points.}

\item{blkSize}{integer of length 1 specifying the minimum size for a syntenic
block and the -s 'size' MCScanX parameter}

\item{maskHits}{data.table of hits that should be excluded}

\item{selfRegionMask}{integer, the radius around self hits that should be
masked}

\item{nhits}{integer, the number of hits to retain}

\item{blks}{data.table containing the block coordinates}

\item{dropInterleavesSmallerThan}{integer, the minimum block size to retain
after splitting overlapping blocks}

\item{minPropDup}{numeric (0-1) specifying the minimum proportion of
duplicated hits to allow two overlapping blocks to not be split}

\item{maxIter}{integer, the maximum number of block splitting interations}

\item{genomeIDs}{an optional vector of genomeIDs to consider. If not
specified (default) taken from gsParam$genomeIDs$genomeIDs}

\item{overwrite}{logical, should the results be overwrittem?}

\item{useBlks}{logical, for cross compatibility with plot_hits}

\item{allowRBHinOG}{logical, for cross compatibility with plot_hits}
}
\description{
\code{utils} Convience functions for genespace, not meant to be called
directly by the user. Little documentation support provided, use at your own
risk.

\code{order_filesByMtime} Order files by date of last modification

\code{check_orthofinderInstall} Check if orthofinder is installed

\code{check_logicalArg} Ensure a logical (length 1) argument is coerced
correctly. If cannot be coerced, return error.

\code{add_rle} Convert vector into run length equivalents

\code{clus_igraph} Clus_igraph

\code{get_nAA} count the number of amino acids by gene

\code{find_modalValue} find the most commmon value in a series

\code{scale_between} scale a vector between a range

\code{complete_subgraph} given a hits data.table, expand unique orthofinder
IDs among all unique elements in a subgraph

\code{flatten_list} convert a list into a vector while keeping names

\code{check_minPepLen} checks for init_genespace

\code{check_dropInterSize} checks for init_genespace

\code{are_colors} check if a vector is coercible to R colors

\code{add_alpha} add transparency to a color

\code{scale_between} ...

\code{pull_strWidth} pull_strWidth

\code{round_toInteger} round_toInteger

\code{calc_partialSw} calc_partialSw

\code{read_gff} reads a genespace-formatted gff-like annotation file into
memory

\code{read_orthofinderSpeciesIDs} Parses the SpeciesIDs.txt file into a
data.table and returns to R.

\code{read_orthofinderSequenceIDs} Reads the sequence
IDs:gene name dictionary into memory.

\code{choose_mostRecentOF} choose_mostRecentOF

\code{parse_ogs} wide to long format conversion for orthogroups.tsv

\code{parse_orthologues} parse_orthologues

\code{read_blast} Reads in a single pairwise orthofinder-formaatted blast
file

\code{draw_scaleBar} draw_scaleBar

\code{cosine_points} vector of points for polygons based on cosine curves

\code{calc_curvePolygon} from 2d coordinates, make a curve

\code{round_rect} from x-y coordinates, make a rounded rectangle

\code{round_rect} from x-y coordinates, make a rounded rectangle

\code{add_ofID2gff} read the orthofinder species and gene IDs and merge
these with the gff-like data.table

\code{add_pepLen2gff} read the peptide lengths and merge with the gff

\code{drop_unusedPeptides} drop_unusedPeptides

\code{prep_ofDbFromPeptide} prep_ofDbFromPeptide

\code{find_orthofinderResults} find_orthofinderResults

\code{calc_blkCoords} calc_blkCoords

\code{finalize_blocks} finalize_blocks

\code{parse_blast4synteny} parse_blast4synteny

\code{find_hitsInBuff} find_hitsInBuff

\code{clus_dbscan} clus_dbscan

\code{find_globalAnchors} find_globalAnchors

\code{pipe_synteny} pipe_synteny

\code{pull_nonSelfReg} pull_nonSelfReg

\code{pull_selfRegion} pull_selfRegion

\code{get_hitsInBlks} get_hitsInBlks

\code{split_overlaps} split_overlaps

\code{annotate_gff} add number of anchors to gff

\code{add_arrayRep2gff} choose most central gene by orthogroup

\code{add_arrays2gff} add_arrays2gff

\code{add_synOg2gff} add_synOg2gff

\code{combine_inblkSynOG} combine_inblkSynOG

\code{pull_nonSynOrthologs} pull_nonSynOrthologs

\code{pull_blkAnchors} pull_blkAnchors
}
