---
title: "GENESPACE README"
author: "JT Lovell"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_depth: '2'
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
```

---
# Overview

A common goal in comparative genomics is to compare gene sequences of many species with reference to the ancestral state. While simple in highly conserved, single copy genes and dipliod/haploid organisms, such alignments are tricky when extending to the biological complexity of most genomes. 

Here, we develop a pipeline to accomplish alignemnts in 'gene-space' (within, or near gene models) to gain a more complete picture of genomic polymorphism among species. The approach can handle any ploidy, ancient or recent whole-genome duplicates, inversions (and other small-scale rearangements) and most other known complexity. Such flexibility is affordered by accomplishing basic comparative genomes tasks within collinear blocks. Once the blocks are constructed, any basic task can be accomplished, knowing that one is comparing evolutionarily related, diploid sequences. 

The pipeline generally performs best when duplications of interest are relatively recent. 

# Setting up the environment

## Install from github:

If the devtools package is not installed, do so first. 

```{r, eval = F}
devtools::install_github("HudsonAlpha/GENESPACE",
                         upgrade = "never",
                         auth_token = "6ad39f2df35eff7a5a4990a1abead1ea74dd33dc")
```

```{r}
library(GENESPACE)
```

## Specify and set the working directory
The pipeline requires only two input directories:

1. `raw_annotations`: this directory contains subdirectories for every genome of interest
2. `raw_assemblies`: the directory contains a single fasta file for every genome of interest. 

These must be placed into the `wd` directory

```{r}
wd = "/Users/jlovell/Desktop/genespace_runs/grasses2"
setwd(wd)
```


## Specify the path the MCScanX program

MCScanX cannot be installed via conda, therefore, we prefer to provide the path to the executable here.

```{r}
MCScanX.path = "/Users/jlovell/Documents/comparative_genomics/programs/MCScanX/MCScanX"
```


## Choose the genomes to work with 

The character vector, `genomeIDs` is used throughout the pipeline and specifies the subset of genomes in the raw directories to analyze. 

```{r}
genomeIDs = c("PhalliiHAL",
              "Sviridis",
              "Sbicolor")
```

To do the pairwise orthofinder runs, it dramatically improves speed to only keep the top *n* hits / gene. Since the number of expected hits varies depending on the ploidy of a genome, we also need to specify the ploidy of each element in `genomeIDs`.

```{r}
ploidy = c(2,2,2)
names(ploidy) <- genomeIDs
```

## Convert raw genome assemblies / annotations into GENESPACE-formatted inputs

GENESPACE requires the CDS and peptide multifasta files to have sequence names that exactly match the geneID element in the gff3-formatted annotation. This is tricky to do, so we offer the convenience function `convert_genomes`, which indexes the assemblies, decompresses any archived files, re-names all files and re-names the fasta headers. 

```{r}
convert_genomes(
  directory = wd,
  genomeIDs = genomeIDs,
  verbose = T,
  transcript_str = "transcript",
  peptide_str = "protein",
  gff_str = "gff3",
  cds_str = "cds")
```

## Make a list of the directory structure and check for dependencies

Throughout the pipeline, we search for files and store results in pre-specified locations. To generate these directory paths, we provide the convenience function `check_environment`, which generates a list of directories. 

```{r}
dirs = check_environment(
  directory = wd,
  genomeIDs = genomeIDs,
  clean = F, check.pkgs = F, check.genomes = F)
dirs$cull.score.blast <- file.path(wd, "cull.score")
```


# Generate syntenic blocks 

The crux of syntenic orthology inference is developing high-confidence syntenic blocks that contain orthologous genes between all pairs of genomes. We find that the best performing method to accomplish this is following:

## Generate orthofinder-formatted blast files for all genomes. 

This should be done first. For just a few genomes, say <= 6, it can be done on a personal computer. However, with more, we suggest running orthofinder on a cluster, or overnight on a personal computer. 

```{r, eval = FALSE}
# -- Do this step on a cluster
# with(dirs,
#      run_orthofinder(
#        peptide.dir = peptide,
#        tmp.dir = tmp,
#        blast.dir = blast))
```

## Parse orthofinder output to keep only the best hits

To produce high-confidence synteny, we typically want to restrict our search to a pre-determined number of copies. For example, we may expect some regions to be duplicated in our genomes. However, we know that regions with 4+ copies likely represent an ancient duplication event. In this case, we would expect, at most, two hits for each haploid genome -- `max.dup == 2`. To subset BLASTp hits accordingly,

```{r}
pw.files <- remake_ofInput(
  dirs = dirs,
  genomeIDs = genomeIDs,
  ploidy = ploidy,
  max.dup = 2)
```


## Run orthofinder for each unique pair of genomes

With culled BLASTp hits in hand, we now need to determine orthology. While this can be done across many genomes, we find that orthofinder is far more stringent when done with fewer genomes. This is likely because duplicate regions can appear more similar within some genomes, thereby allowing orthologous networks to permiate into less desirable, ancient duplicated regions. 

```{r}
pw.blocks <- build_pwBlocks(
  dir.list = dirs,
  of.cores = 8,
  MCScanX.path = MCScanX.path,
  genomeIDs = genomeIDs)
```

## Build syntenic blocks

From a blast data.table with a column `block.id`, we can create the physical coordinates of blocks, and some summary statistics via: 

```{r}
sb <- make_blocks(
  pw.blocks$map, 
  clean.columns = F)
```

## View pairwise synteny

We can represent synteny as a pairwise view of orthologous BLASTp hits

```{r}
with(sb,
     plot_mapping(map = map,
                  blk = block,
                  genomes = genomeIDs[c(1:2)]))
```

## Clean the blocks

This is the primary step where parameterization can dramatically affect the results. More hits in a smaller radius will drop regions with less dense hits. We suggest leaving these parameters as relatively lax, with large radii and small number of hits. For example, here, we do two iterations, one needing 50 hits across 300 genes and the second with 10 hits in 50-gene windows. 

```{r}
cleaned <- clean_blocks(
  map = pw.blocks$map,
  radius = c(300,50),
  n.mappings = c(50,10),
  n.cores = 1, clean.columns = F)

with(cleaned,
     plot_mapping(map = map,
                  blk = block,
                  genomes = genomeIDs[c(1:2)]))
```

## Check if we missed any small syntenic blocks.

It is possible that our cleaning and block-building steps dropped small blocks that are real. To check for these, we first import all gff3-annotations: 

```{r}
gff <- import_gff(
  gff.dir = dirs$gff,
  genomeIDs = genomeIDs)
```

and initial (complete, not pairwise) orthofinder orthogroups:

```{r}
full.of.results <- import_ofResults(
  gff = gff,
  blast.dir = dirs$blast,
  genomeIDs = genomeIDs)
```

and BLASTp hits in orthogroups:

```{r}
full.ogblast <- with(full.of.results,
                      import_ofBlast(
                        species.mappings = species.mappings,
                        genomeIDs = genomeIDs,
                        orthogroups = orthogroups,
                        gff = gff,
                        gene.index = gene.index))
```

We then look for any orthologous BLASTp hits that pass block-cleaning thresholds and are within a buffer of known blocks. Finally, we free up some memory by deleting the orthogroup-restricted blast results. 

```{r}
extended <- extend_blocks(
  gff = gff,
  map = cleaned$map,
  blast = full.ogblast,
  plotit = F,
  n.cores = 1,
  n.iter = 1,
  rank.buffer = 250,
  n.mappings = 5,
  radius = 20)
rm(list = c("full.ogblast"))
```


# Infer syntenic orthology

The goal of syntenic block construction is to develop a map, within which we expect to find orthologs. With this map in hand, we can restrict our BLASTp hits to those within syntenic blocks. This permits inference of syntenic orthology, as any genes in orthology networks. 

## Load BLASTp results

To accomplish this, we first read in all blast results, even those that are not in orthogroups. One can optionally drop low scoring hits (here hits must be > 50) or those that are not near the highest score for a given gene (here hits must be > 25% of the maximum score for a gene). These parameters do not dramatically affect the results, but do improve speed.

```{r}
full.allblast <- with(full.of.results,
                      import_ofBlast(
                        species.mappings = species.mappings,
                        genomeIDs = genomeIDs,
                        orthogroups = orthogroups,
                        gene.index = gene.index,
                        min.score = 50,
                        prop.topscore = .25,
                        gff = gff,
                        verbose = T,
                        only.orthologs = F))
```

## Re-run orthofinder on only syntenic BLASTp hits

This is the crucial step. Since we are inputting known syntenic hits, all ortholog networks are, by definition syntenic. `find_syntenicOrthologs` runs the `extend_blocks` pipeline, here keeping any blast hit within 100 genes of a known syntenic block. 

```{r}
syn.og <- find_syntenicOrthogs(
  blast = full.allblast,
  map = extended$map,
  genomeIDs = genomeIDs,
  rank.buffer = 100,
  dir.list = dirs,
  gff = gff,
  n.cores = 4,
  verbose = T)
rm(list = c("full.allblast"))
```

## Make the blocks and plot

Like before, have a look at synteny. Note that there is more noise around the blocks, as we allowed for a 100-gene rank buffer. 

```{r}
syn.blk <- make_blocks(syn.og$map, clean.columns = F)
with(syn.blk,
     plot_mapping(map = map,
                  blk = block,
                  genomes = genomeIDs[c(1:2)]))
```

# Find tandem array

A large proportion of genes (~5-20%) are typically found in multiple nearby copies. This is both interesting on its own (in terms of molecular evolution) but also a problem for downstream analyses -- the network searches become tricky when looking for pseudogenes or qualifying duplicate regions. 

## Qualify hits in arrays

To get around this, we simply set any hits in an orthogroup that are within the same block as 'tandem arrays'. The downstream functions know what to do with these - e.g. compress each array into a single most-representative / highest scoring hit. We start by setting any array with >1 hit. 

```{r}
all.tandemArrays <- find_tandemArrays(
  map = syn.blk$map,
  min.hits1 = 1,
  min.hits2 = 1)
```

## Quantify large arrays

We also may want to understand array proliferation. To do this, we may want to be a bit more stringent with out array inference. 

```{r}
large.tandemArrays <- find_tandemArrays(
  map = syn.blk$map,
  min.hits1 = 3,
  min.hits2 = 2)
```

## Find orthology networks by copy number in each genome

Now that we have controlled for tandem arrays, we can pull out genes, qualifying them by copy number. 

```{r}
orthonet <- pull_orthoNet(blast = all.tandemArrays,
                          genomeIDs = genomeIDs,
                          drop.tandems = T)
```

# Find pseudogenes

Looking at the distribution of hits in `orthonet`, you may notice that there are a lot of incomplete networks, where there are no hits in one or more of your genomes. We can use the positional information of neighbors to these missing hits to find syntenic regions that have similar sequence. 

```{r}
pgenes <- find_pseudogenes(map = all.tandemArrays,
                           gff = gff,
                           genomeIDs = genomeIDs,
                           dir.list = dirs,
                           max.window.bp = 1e5,
                           n.cores.blast = 16)
```

Stoping here ... 
```{r}
save(pgenes, syn.og, pw.blocks, file = "~/Desktop/genespace_example.rda")
```


<!-- pse <- pgenes$exonerate.summary -->
<!-- pse$genome1 <- factor(pse$genome1, levels = genomeIDs) -->
<!-- pse$genome2 <- factor(pse$genome2, levels = genomeIDs) -->
<!-- pse$og1 <- pse$og -->
<!-- pse$og2 <- pse$og -->
<!-- pgene.map <- rbind(all.tandemArrays, pse, fill = T) -->
<!-- pgene.orthonet <- pull_orthoNet( -->
<!--   blast = pgene.map, -->
<!--   genomeIDs = genomeIDs, -->
<!--   drop.tandems = T) -->

<!-- orthonet <- pull_orthoNet(blast = map.ta, -->
<!--                           genomeIDs = genomeIDs, -->
<!--                           drop.tandems = T) -->



<!-- plt.db <- plot_multiSynteny2(map = map2plot$map, -->
<!--                              chr.order.list = chr.list, -->
<!--                              genes2highlight = chr1.genes, -->
<!--                              clean.radius = 15, clean.nmappings = 10, -->
<!--                              highlight.col = rgb(1,.2,.2,.1), -->
<!--                              highlight.lwd = .5, uni.dir = T) -->






<!-- mc1 <- cleaned$map[,list(nhits = .N), -->
<!--                       by = list(genome1,chr1)] -->
<!-- mc2 <- cleaned$map[,list(nhits = .N), -->
<!--                       by = list(genome2,chr2)] -->
<!-- setnames(mc2, colnames(mc1)) -->
<!-- mc <- rbind(mc1, mc2)[,list(nhits = sum(nhits)), -->
<!--                       by = list(genome1, chr1)] -->
<!-- barplot(mc$nhits) -->
<!-- abline(h = 1000) -->

<!-- good.chr <- mc$chr1[mc$nhits > 1000] -->
<!-- mc$chr1[mc$nhits < 1000] -->
<!-- good.chr <- mc$chr1[mc$nhits > 1000] -->
<!-- map2plot <- make_blocks( -->
<!--   subset(cleaned$map, -->
<!--          chr1 %in% good.chr & chr2 %in% good.chr)) -->

<!-- chr.list <- match_syntenicChrs( -->
<!--   map = map2plot$map, -->
<!--   genomeIDs = genomeIDs, -->
<!--   genome1.chrs = paste0("Chr0",c(1:9))) -->

