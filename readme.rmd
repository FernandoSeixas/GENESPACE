---
title: "README"
author: "JT Lovell"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_depth: '2'
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
```

---
# Overview

A common goal in comparative genomics is to compare gene sequences of many species with reference to the ancestral state. While simple in highly conserved, single copy genes and dipliod/haploid organisms, such alignments are tricky when extending to the biological complexity of most genomes. 

Here, we develop a pipeline to accomplish alignemnts in "gene space" (within, or near gene models) to gain a more complete picture of genomic polymorphism among species. The approach can handle any ploidy, ancient or recent whole-genome duplicates, inversions (and other small-scale rearangements) and most other known complexity. Such flexibility is affordered by accomplishing basic comparative genomes tasks within collinear blocks. Once the blocks are constructed, any basic task can be accomplished, knowing that one is comparing evolutionarily related, diploid sequences. 

## General pipeline

1. pairwise blast search --> colinear blocks of genes
2. orthofinder within colinear blocks --> genes missing in at least one genome
3. blat search within blocks for orthologs of missing genes --> regions containing missing sequence
4. exonerate missing sequence --> pseudo-CDS of unannotated sequence
5. multiple sequence alignemnt of all sequences --> sequence divergence statistics

## Outputs

1. List of single copy orthologs between each pair of genomes
2. List of genes without orthologous sequences in each genome
3. Mapping file with the positions of genes in colinear blocks between each pair of genomes
4. Block file with coordinates of collinear blocks between each pair of genomes
3. Multiple sequence alignments for each orthogroup (tested within colinear blocks)

# Simple block construction

Often, we are only interested in building blocks and not in alignments / pseudogene reconstruction. To do this simple analysis, we only need the peptide and gff directories. 



# Getting started

## Input data

Each genome must have five datasets

1. Annotation file (gff3 format)
2. Peptide fasta file of the primary transcript for each gene
3. CDS fasta file of the primary transcript for each gene
4. Full-length transcript fasta file of the primary transcript for each gene
5. Genomic assembly fasta

To get started, make a project directory, e.g.:

`mkdir /Users/jlovell/Desktop/grass_genespace`
`cd /Users/jlovell/Desktop/grass_genespace`

Then make two raw data subdirectories, e.g.: 

`mkdir raw_annotations`
`mkdir raw_assemblies`

Copy all the assembly fasta files into the raw_assemblies directory and rename them as `[genomeID].fa`. 

Make a subdirectory named [genomeID] for each `genomeID` in the raw_annotations directory. Place the four annotation files of each genomeID into the respective subdirectories. It doesn't matter what the annotations are named, as long as there is a distinguishing character string in each file name that identifies the type of annotation file. For example, the CDS fastas may all have `cds_primaryTranscriptOnly` in their names. 


## Conda environment

Launch the conda environment with the basic programs that are required
```
source activate /global/dna/projectdirs/plant/geneAtlas/HAGSC_TOOLS/ANACONDA_ENVS/genespace
```


Install MCScanX from http://chibba.pgml.uga.edu/mcscan2/MCScanX.zip,

  If having trouble with installation, see troubleshooting here: https://vcru.wisc.edu/simonlab/bioinformatics/programs/install/mcscanx.htm

Then specify the path to MCSCanX:

``` 
export PATH=$PATH:/global/projectb/scratch/jtlovell/MCScanX
```


Otherwise 

```
R
```

Download the tarball
```

```

Within R, install genespace
```
install.packages("geometry")
install.packages("dbscan")
install.packages("data.table")
  library(devtools)
  devtools::build("/global/projectb/scratch/jtlovell/test_genespace/GENESPACE")
  devtools::install("/global/projectb/scratch/jtlovell/test_genespace/GENESPACE")
```

If you are not on NERSC, you can do this instead.

```
> library(devtools)
> devtools::install_github("HudsonAlpha/GENESPACE",
               auth_token = "6ad39f2df35eff7a5a4990a1abead1ea74dd33dc")

```

Finally, specify the working data for the project:
```
directory = "/Users/jlovell/Desktop/grass_genespace"
block.dir = file.path(directory,"block.data")
genomeIDs = c("Pvirgatum",  "PhalliiHAL", "Sviridis")
```

## Automatic formatting of input data

GENESPACE requires a very specific naming and file structure of the input data ... within the project directory, there needs to be a folder called `genomes`. This contains five subdirectories:

1. assembly
2. peptide
3. cds
4. transcript
5. gff

Each of these needs to be populated with a file for each genome named [genomeID].fa, or [genomeID].gff3. Making these files can be annoying, so there is a conveniece function:

```
convert_genomes(
  directory = directory,
  genomeIDs = genomeIDs,
  verbose = T)
```

This parses the fasta and gff files into the correct directory structure

## Check that everything is ready

Since formatting is tricky and there are a lot of dependencies for this pipeline, I have a convenience function to make sure everything is OK.

```
check_environment(
  directory = directory,
  genomeIDs = genomeIDs,
  abbrevs = c("Pv","Ph","Sv"),
  ploidy = c(4,2,2))
```


# Run the mapping / synteny pipeline

## Initial BLAST and orthology network construction

The first step is to run pairwise / reciprocal blasts and build initial gene orthology networks. We accomplish this within the orthofinder program, which can be called via:

```
run_orthofinder(
  peptide.dir = peptide.dir,
  tmp.dir = tmp.dir,
  blast.dir = blast.dir)
```

## BLAST-result parsing

Orthofinder returns a relatively complex file structure. What we are interested in are blast hits that reside within orthology networks, pass certain score thresholds, etc.

Furthermore, syntenic blocks are identified by regions of dense blast hits on pairwise chromosomal regions. Therefore, to speed up collinear block construction and increase accuracy, we also parse by the 2D density of BLAST hits. This is determined by the gene position rank of the hits on each pairwise set of genomes.

```
blast.results <- parse_orthofinder(
  blast.dir = blast.dir,
  gff.dir = gff.dir,
  ploidy = ploidy)
```

The defaults in parse_orthofinder do a good 








